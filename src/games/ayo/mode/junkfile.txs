// AyoComputerUI.tsx - Computer play UI with level selector fix
import React, { useState, useEffect, useMemo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Button, ActivityIndicator } from 'react-native';
import { initializeComputerGame, playComputerTurn, AyoComputerState, ComputerLevel, getComputerMove } from "./AyoComputerLogic";
import { calculateMoveResult } from "../core/AyoCoreLogic";
import {AyoGame} from "../core/AyoCoreUI"; // Make sure import points to the correct AyoGame
import { usePlayerProfile } from '@/src/hooks/usePlayerProfile';

const levels = [
  { label: "Rookie (Easy)", value: 1, rating: 1000, reward: 10 },
  { label: "Player (Normal)", value: 2, rating: 1250, reward: 20 },
  { label: "Warrior (Hard)", value: 3, rating: 1500, reward: 30 },
  { label: "Master (Expert)", value: 4, rating: 1700, reward: 40 },
  { label: "Alpha (Legend)", value: 5, rating: 1900, reward: 50 },
];

const BATTLE_BONUS = 20;

export default function AyoComputerUI() {
  const [gameState, setGameState] = useState<AyoComputerState | null>(null);
  const [level, setLevel] = useState<ComputerLevel | null>(null);
  const [animationPaths, setAnimationPaths] = useState<number[][]>([]);
  const [aiThinking, setAiThinking] = useState(false);
  const playerProfile = usePlayerProfile();
  const [isAnimating, setIsAnimating] = useState(false);
  const [pendingMove, setPendingMove] = useState<{ player: 1 | 2; pit: number } | null>(null);

  const startGame = (lvl: ComputerLevel) => {
    setLevel(lvl); // This updates selected level correctly
    setGameState(initializeComputerGame(lvl));
  };

  const onAnimationDone = () => {
    if (pendingMove && gameState) {
      const newState = playComputerTurn(gameState, pendingMove.pit);
      setGameState(newState);
      if (pendingMove.player === 1) { // AI is Player 1
        setAiThinking(false);
      }
    }
    setIsAnimating(false);
    setPendingMove(null);
    setAnimationPaths([]);
  };

  const handleMove = (pitIndex: number) => {
    if (!gameState || isAnimating || gameState.game.currentPlayer !== 2) return;

    const moveResult = calculateMoveResult(gameState.game, pitIndex);
    if (moveResult.animationPaths.length > 0) {
      setIsAnimating(true);
      setPendingMove({ player: 2, pit: pitIndex });
      setAnimationPaths(moveResult.animationPaths);
    } else {
      const newState = playComputerTurn(gameState, pitIndex);
      setGameState(newState);
    }
  };

  useEffect(() => {
    if (!gameState || !level || isAnimating || gameState.game.currentPlayer !== 1 || gameState.isPlayerWinner !== null) {
      return;
    }

    setAiThinking(true);
    const timer = setTimeout(() => {
      if (!gameState || gameState.game.currentPlayer !== 1) {
        setAiThinking(false);
        return;
      }

      const aiMove = getComputerMove(gameState.game, level);
      const moveResult = calculateMoveResult(gameState.game, aiMove);

      if (moveResult.animationPaths.length > 0) {
        setIsAnimating(true);
        setPendingMove({ player: 1, pit: aiMove });
        setAnimationPaths(moveResult.animationPaths);
      } else {
        const newState = playComputerTurn(gameState, aiMove);
        setGameState(newState);
        setAiThinking(false);
      }
    }, 800);

    return () => clearTimeout(timer);
  }, [gameState, level, isAnimating]);

  const opponent = useMemo(() => {
    if (!level) return null;
    const levelData = levels.find(l => l.value === level);
    return {
      name: `${levelData?.label.split(' ')[0]} AI`,
      country: "NG",
      rating: levelData?.rating || 1000,
      isAI: true,
    };
  }, [level]);

  return (
    <View style={styles.container}>
      {!gameState ? (
        <View style={styles.levelSelector}>
          <Text style={styles.title}>Choose Difficulty</Text>
          {levels.map((lvl) => (
            <TouchableOpacity
              key={lvl.value}
              style={styles.levelButton}
              onPress={() => startGame(lvl.value as ComputerLevel)}
            >
              <Text style={styles.levelText}>{lvl.label}</Text>
            </TouchableOpacity>
          ))}
        </View>
      ) : (
        <View style={styles.gameContainer}>
          <AyoGame
             initialGameState={gameState.game}
             onPitPress={handleMove}
             opponent={opponent}
              
             player={{ name: playerProfile?.name ?? 'You', country: playerProfile?.country ?? 'NG', rating: playerProfile?.rating ?? 1200, isAI: false }}
           />


          {aiThinking && <ActivityIndicator size="large" color="#fff" style={{ marginTop: 10 }} />}

          {gameState.isPlayerWinner !== null && (
            <View style={styles.resultBox}>
              {gameState.isPlayerWinner ? (
                <Text style={styles.winText}>
                  ðŸŽ‰ You Win! +{gameState.reward} R-coin
                </Text>
              ) : (
                <Text style={styles.loseText}>ðŸ˜¢ You Lost!</Text>
              )}
              <Button title="Play Again" onPress={() => level && setGameState(initializeComputerGame(level))} />
            </View>
          )}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 10, backgroundColor: '#222' },
  levelSelector: { justifyContent: 'center', alignItems: 'center', flex: 1 },
  title: { color: 'white', fontSize: 20, marginBottom: 20 },
  levelButton: { backgroundColor: '#444', padding: 12, borderRadius: 8, marginVertical: 6, width: '80%', alignItems: 'center' },
  levelText: { color: 'white', fontSize: 18 },
  gameContainer: { flex: 1 },
  resultBox: { marginTop: 20, alignItems: 'center' },
  winText: { color: 'lime', fontSize: 20, marginBottom: 10 },
  loseText: { color: 'red', fontSize: 20, marginBottom: 10 },
});



// AyoCoreLogic.ts - core game logic
export interface AyoGameState {
  board: number[];
  scores: { [key: number]: number };
  currentPlayer: 1 | 2;
  isGameOver: boolean;
  timerState: {
    player1Time: number;
    player2Time: number;
    isRunning: boolean;
    lastActivePlayer: 1 | 2;
  };
}

export interface Capture {
  pitIndex: number;
  awardedTo: 1 | 2;
}

export interface MoveResult {
  nextState: AyoGameState;
  animationPaths: number[][];
  captures: Capture[];
}

export const PLAYER_ONE_PITS = [0, 1, 2, 3, 4, 5];
export const PLAYER_TWO_PITS = [6, 7, 8, 9, 10, 11];
export const CCW_ORDER = [5, 4, 3, 2, 1, 0, 6, 7, 8, 9, 10, 11];

const getNextPit = (currentIndex: number): number => {
  const currentPos = CCW_ORDER.indexOf(currentIndex);
  const nextPos = (currentPos + 1) % 12;
  return CCW_ORDER[nextPos];
};

export const initializeGame = (): AyoGameState => {
  const startingPlayer = Math.random() < 0.5 ? 1 : 2;
  return {
    board: Array(12).fill(4),
    scores: { 1: 0, 2: 0 },
    currentPlayer: startingPlayer,
    isGameOver: false,
    timerState: {
      player1Time: 600,
      player2Time: 600,
      isRunning: false,
      lastActivePlayer: startingPlayer,
    },
  };
};

export const calculateMoveResult = (
  state: AyoGameState,
  pitIndex: number
): MoveResult => {
  let { board, scores, currentPlayer } = state;
  board = [...board];
  scores = { ...scores };

  let seeds = board[pitIndex];
  if (
    seeds === 0 ||
    (currentPlayer === 1 && !PLAYER_ONE_PITS.includes(pitIndex)) ||
    (currentPlayer === 2 && !PLAYER_TWO_PITS.includes(pitIndex))
  ) {
    return { nextState: state, animationPaths: [], captures: [] };
  }

  const initialTotalSeeds = board.reduce((a, b) => a + b, 0);
  const isEightSeedRuleActive = initialTotalSeeds === 8;

  const animationPaths: number[][] = [];
  const captures: Capture[] = [];
  let currentIndex = pitIndex;

  const handleCapture = (pitIdx: number, isLastSeedOfSow: boolean) => {
    const pitOwner: 1 | 2 = PLAYER_ONE_PITS.includes(pitIdx) ? 1 : 2;
    let awardedTo: 1 | 2 = isLastSeedOfSow && pitOwner !== currentPlayer ? currentPlayer : pitOwner;
    captures.push({ pitIndex: pitIdx, awardedTo });
    board[pitIdx] = 0;
  };

  // Initial sow
  let currentPath: number[] = [pitIndex];
  board[pitIndex] = 0;
  while (seeds > 0) {
    currentIndex = getNextPit(currentIndex);
    board[currentIndex]++;
    seeds--;
    currentPath.push(currentIndex);
    if (board[currentIndex] === 4) {
      if (isEightSeedRuleActive) {
        scores[currentPlayer] += 8;
        return {
          nextState: { ...state, scores, board: Array(12).fill(0), isGameOver: true },
          animationPaths: [currentPath],
          captures: [],
        };
      }
      handleCapture(currentIndex, seeds === 0);
    }
  }
  animationPaths.push(currentPath);

  // Relay sowing
  let shouldRelay = board[currentIndex] > 1;
  while (shouldRelay) {
    seeds = board[currentIndex];
    currentPath = [currentIndex];
    board[currentIndex] = 0;
    while (seeds > 0) {
      currentIndex = getNextPit(currentIndex);
      board[currentIndex]++;
      seeds--;
      currentPath.push(currentIndex);
      if (board[currentIndex] === 4) {
        handleCapture(currentIndex, seeds === 0);
      }
    }
    animationPaths.push(currentPath);
    const wasLastPitCaptured = captures.some(c => c.pitIndex === currentIndex);
    shouldRelay = board[currentIndex] > 1 && !wasLastPitCaptured;
  }

  const isGameOver = board.reduce((a, b) => a + b, 0) === 0;
  let nextPlayer: 1 | 2 = currentPlayer === 1 ? 2 : 1;

  if (!isGameOver) {
    const opponentPits = nextPlayer === 1 ? PLAYER_ONE_PITS : PLAYER_TWO_PITS;
    const opponentHasMoves = opponentPits.some((pit) => board[pit] > 0);
    if (!opponentHasMoves) {
      nextPlayer = currentPlayer;
    }
  }

  return {
    nextState: {
      ...state,
      board,
      scores,
      currentPlayer: isGameOver ? currentPlayer : nextPlayer,
      isGameOver,
    },
    animationPaths,
    captures,
  };
};

export const getValidMoves = (state: AyoGameState): number[] => {
  const pits = state.currentPlayer === 1 ? PLAYER_ONE_PITS : PLAYER_TWO_PITS;
  return pits.filter((idx) => state.board[idx] > 0);
};



// AyoGame.tsx - main game UI
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { View, Text, StyleSheet, Alert } from "react-native";
import { AyoSkiaImageBoard } from "./AyoSkiaBoard";
import PlayerProfileCompact from "@/src/screens/profile/PlayerProfileCompact";
import {
  AyoGameState,
  initializeGame,
  calculateMoveResult,
  getValidMoves,
  Capture,
} from "./AyoCoreLogic";
import { useGameTimer } from "@/src/hooks/useGameTimer";
import { StyleProp, ViewStyle, TextStyle } from 'react-native';

type AyoGameProps = {
  initialGameState?: AyoGameState;
  onPitPress?: (pitIndex: number) => void;
  player?: { name: string; country?: string; rating?: number; isAI?: boolean };
  opponent?: { name: string; country?: string; rating?: number; isAI?: boolean };
};

export const AyoGame: React.FC<AyoGameProps> = ({ initialGameState, onPitPress, player: propPlayer, opponent: propOpponent }) => {

  const [gameState, setGameState] = useState<AyoGameState>(initialGameState ?? initializeGame());
  const [boardBeforeMove, setBoardBeforeMove] = useState<number[]>(gameState.board);
  const [animatingPaths, setAnimatingPaths] = useState<number[][]>([]);
  const [captures, setCaptures] = useState<Capture[]>([]);
  
  // fallback players (used only when props not supplied)
  const defaultPlayer = { name: "Player", country: "NG", rating: 1200, isAI: false };
  const defaultOpponent = { name: "Opponent", country: "US", rating: 1500, isAI: true };

  const player = propPlayer ?? defaultPlayer;
  const opponent = propOpponent ?? defaultOpponent;

  const { player1Time, player2Time, startTimer, pauseTimer, formatTime, setLastActivePlayer } = useGameTimer(300);

  const isAnimating = animatingPaths.length > 0;

  useEffect(() => {
    if (gameState.currentPlayer === 1 && !gameState.isGameOver && !isAnimating) {
      const validMoves = getValidMoves(gameState);
      if (validMoves.length === 0) return;
      const aiMove = validMoves.reduce((best, pit) => gameState.board[pit] > gameState.board[best] ? pit : best);
      const timerId = setTimeout(() => {
        setBoardBeforeMove(gameState.board);
        const moveResult = calculateMoveResult(gameState, aiMove);
        setAnimatingPaths(moveResult.animationPaths);
        setCaptures(moveResult.captures);
        setGameState(moveResult.nextState);
      }, 800);
      return () => clearTimeout(timerId);
    }
  }, [gameState, isAnimating]);

  useEffect(() => {
    if (gameState.isGameOver) {
      pauseTimer();
      return;
    }
    if (isAnimating) {
      pauseTimer();
      return;
    }
    setLastActivePlayer(gameState.currentPlayer);
    if (gameState.currentPlayer === 1) {
      pauseTimer();
    } else if (gameState.currentPlayer === 2) {
      startTimer();
    }
  }, [gameState.currentPlayer, gameState.isGameOver, isAnimating, setLastActivePlayer, pauseTimer, startTimer]);

  useEffect(() => {
    const handleTimeout = (winner: 1 | 2) => {
      const winnerName = winner === 2 ? "Player" : "Opponent";
      const loserName = winner === 2 ? "Opponent" : "Player";
      Alert.alert("Time's Up!", `${loserName} ran out of time. ${winnerName} wins!`);
      setGameState(prev => ({ ...prev, isGameOver: true, currentPlayer: winner }));
    };
    if (player1Time <= 0) handleTimeout(2);
    if (player2Time <= 0) handleTimeout(1);
  }, [player1Time, player2Time]);

  const handlePlayerMove = useCallback((pitIndex: number) => {
    if (gameState.currentPlayer !== 2 || isAnimating) return;
    pauseTimer();
    setBoardBeforeMove(gameState.board);
    const moveResult = calculateMoveResult(gameState, pitIndex);
    setAnimatingPaths(moveResult.animationPaths);
    setCaptures(moveResult.captures);
    setGameState(moveResult.nextState);

    // also call parent's onPitPress if provided
    if (onPitPress) onPitPress(pitIndex);
  }, [gameState, isAnimating, pauseTimer, onPitPress]);


  const handleCaptureDuringAnimation = useCallback((pitIndex: number) => {
    const captureInfo = captures.find((c) => c.pitIndex === pitIndex);
    if (!captureInfo) return;
    setGameState(prevState => {
      const newScores = { ...prevState.scores };
      newScores[captureInfo.awardedTo] += 4;
      return { ...prevState, scores: newScores };
    });
  }, [captures]);

  const handleAnimationEnd = useCallback(() => {
    setAnimatingPaths([]);
    setCaptures([]);
  }, []);

  const memoizedPaths = useMemo(() => animatingPaths, [animatingPaths]);
  const memoizedCaptures = useMemo(() => captures.map(c => c.pitIndex), [captures]);

  return (
    <View style={styles.container as StyleProp<ViewStyle>}>
      <View style={styles.profileContainer as StyleProp<ViewStyle>}>
        <PlayerProfileCompact {...opponent} score={gameState.scores[1]} timeLeft={formatTime(player1Time)} isActive={gameState.currentPlayer === 1 && !isAnimating} />
      </View>
      <View style={styles.boardContainer as StyleProp<ViewStyle>}>
        <AyoSkiaImageBoard board={gameState.board} boardBeforeMove={boardBeforeMove} onPitPress={handlePlayerMove} animatingPaths={memoizedPaths} captures={memoizedCaptures} onAnimationEnd={handleAnimationEnd} onCaptureDuringAnimation={handleCaptureDuringAnimation} />
      </View>
      <View style={styles.profileContainer as StyleProp<ViewStyle>}>
        <PlayerProfileCompact {...player} score={gameState.scores[2]} timeLeft={formatTime(player2Time)} isActive={gameState.currentPlayer === 2 && !isAnimating} />
      </View>
      {gameState.isGameOver && (
        <Text style={styles.gameOver as StyleProp<TextStyle>}>
          Game Over! Winner:{" "}
          {gameState.scores[2] > gameState.scores[1] ? player.name : gameState.scores[1] > gameState.scores[2] ? opponent.name : "Draw"}
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'space-between', padding: 10, backgroundColor: '#222' },
  profileContainer: { alignItems: 'center', marginBottom: 12 },
  boardContainer: { flex: 1, justifyContent: 'center' },
  gameOver: { color: 'white', fontSize: 18, textAlign: 'center', marginTop: 10 },
});


// AyoSkiaImageBoard.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useWindowDimensions } from 'react-native';
import {
  Canvas,
  Image as SkiaImage,
  useImage,
  Group,
  Skia,
} from '@shopify/react-native-skia';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useDerivedValue,
  withTiming,
  withSequence,
  runOnJS,
  Easing,
  cancelAnimation,
} from 'react-native-reanimated';
import { useSound } from '@/src/hooks/useSound';
import hopSound from '@/src/assets/sounds/hop.mp3';
import captureSound from '@/src/assets/sounds/capture.mp3';
import { useBackgroundSound } from "@/src/hooks/useBackgroundSound";
import bgSound from "@/src/assets/sounds/background.mp3";

const boardImageSource = require('@/src/assets/images/ayo-board.png');
const seedImageSource = require('@/src/assets/images/ayo-seed.png');
const SEED_IMAGE_SIZE = 45;

const getSeedPosition = (pitX: number, pitY: number, seedIndex: number, totalSeeds: number) => {
  const angle = (seedIndex / Math.max(1, totalSeeds)) * 2 * Math.PI;
  const radius = totalSeeds > 1 ? 15 : 0;
  const x = pitX + Math.cos(angle) * radius - SEED_IMAGE_SIZE / 2;
  const y = pitY + Math.sin(angle) * radius - SEED_IMAGE_SIZE / 1.3;
  return { x, y };
};

export const generatePitPositions = (rows: number, cols: number, boardWidth: number, boardHeight: number, marginX: number = 0.02, marginY: number = 0.1) => {
  const effectiveWidth = boardWidth * (1 - 2 * marginX);
  const effectiveHeight = boardHeight * (1 - 2 * marginY);
  const leftOffset = boardWidth * marginX;
  const topOffset = boardHeight * marginY;
  const cellWidth = effectiveWidth / cols;
  const cellHeight = effectiveHeight / rows;
  const radius = Math.min(cellWidth, cellHeight) / 2 - 5;
  const pits: { index: number; x: number; y: number; r: number }[] = [];
  let index = 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      pits.push({ index: index++, x: leftOffset + (c + 0.5) * cellWidth, y: topOffset + (r + 0.5) * cellHeight, r: radius });
    }
  }
  return pits;
};

interface AnimationStep {
  path: number[];
  boardStateBeforeSow: number[];
}

interface AyoSkiaImageBoardProps {
  board: number[];
  boardBeforeMove: number[];
  animatingPaths?: number[][];
  captures?: number[];
  onPitPress: (pitIndex: number) => void;
  onAnimationEnd?: () => void;
  onCaptureDuringAnimation?: (pitIndex: number) => void;
}

export const AyoSkiaImageBoard: React.FC<AyoSkiaImageBoardProps> = ({ board, boardBeforeMove, animatingPaths, captures, onPitPress, onAnimationEnd, onCaptureDuringAnimation }) => {
  const isAnimating = !!animatingPaths && animatingPaths.length > 0;
  const { play: playHop } = useSound(hopSound);
  const { play: playCapture } = useSound(captureSound);
  useBackgroundSound(bgSound);
  const [animationBoard, setAnimationBoard] = useState<number[] | null>(null);
  const [animationSteps, setAnimationSteps] = useState<AnimationStep[]>([]);
  const animationTimers = useRef<NodeJS.Timeout[]>([]);
  const boardImage = useImage(boardImageSource);
  const seedImage = useImage(seedImageSource);
  const animatedX = useSharedValue(0);
  const animatedY = useSharedValue(0);
  const animatedOpacity = useSharedValue(0);
  const { width: screenWidth } = useWindowDimensions();

  const BOARD_IMAGE_WIDTH = 721;
  const BOARD_IMAGE_HEIGHT = 300;
  const BOARD_ASPECT_RATIO = BOARD_IMAGE_WIDTH / BOARD_IMAGE_HEIGHT;
  const canvasWidth = screenWidth * 0.95;
  const canvasHeight = canvasWidth / BOARD_ASPECT_RATIO;
  const scale = canvasWidth / BOARD_IMAGE_WIDTH;

  const PIT_POSITIONS = useMemo(() => generatePitPositions(2, 6, BOARD_IMAGE_WIDTH, BOARD_IMAGE_HEIGHT), []);

  const tapGesture = Gesture.Tap().onEnd(({ x, y }) => {
    if (isAnimating) return;
    const scaledX = x / scale;
    const scaledY = y / scale;
    for (const pit of PIT_POSITIONS) {
      if (Math.sqrt((pit.x - scaledX) ** 2 + (pit.y - scaledY) ** 2) < pit.r) {
        if (pit.index >= 6) runOnJS(onPitPress)(pit.index);
        return;
      }
    }
  });

  useEffect(() => {
    if (!animatingPaths || animatingPaths.length === 0) {
      setAnimationSteps([]);
      return;
    }
    const steps: AnimationStep[] = [];
    let tempBoard = [...boardBeforeMove];
    for (const path of animatingPaths) {
      if (path.length > 0) {
        const startPit = path[0];
        const boardStateBeforeSow = [...tempBoard];
        boardStateBeforeSow[startPit] = 0;
        steps.push({ path, boardStateBeforeSow });
        let finalBoardForStep = [...boardStateBeforeSow];
        for (let i = 1; i < path.length; i++) {
          const pitIdx = path[i];
          finalBoardForStep[pitIdx]++;
          if (captures?.includes(pitIdx) && finalBoardForStep[pitIdx] === 4) {
            finalBoardForStep[pitIdx] = 0;
          }
        }
        tempBoard = finalBoardForStep;
      }
    }
    setAnimationSteps(steps);
  }, [animatingPaths, boardBeforeMove, captures]);

  useEffect(() => {
    cancelAnimation(animatedX);
    cancelAnimation(animatedY);
    cancelAnimation(animatedOpacity);
    animationTimers.current.forEach(clearTimeout);
    animationTimers.current = [];

    if (animationSteps.length === 0) {
      animatedOpacity.value = 0;
      if (animationBoard) runOnJS(setAnimationBoard)(null);
      return;
    }

    const incrementSeedInPit = (pitIndex: number) => {
      setAnimationBoard(prevBoard => {
        if (!prevBoard) return null;
        const newBoard = [...prevBoard];
        newBoard[pitIndex]++;
        runOnJS(playHop)();
        if (newBoard[pitIndex] === 4 && captures?.includes(pitIndex)) {
          newBoard[pitIndex] = 0;
          if (onCaptureDuringAnimation) {
            runOnJS(playCapture)();
            runOnJS(onCaptureDuringAnimation)(pitIndex);
          }
        }
        return newBoard;
      });
    };

    const playAnimationForStep = (stepIndex: number) => {
      if (stepIndex >= animationSteps.length) {
        animatedOpacity.value = withTiming(0, { duration: 120 }, finished => {
          if (finished && onAnimationEnd) runOnJS(onAnimationEnd)();
        });
        return;
      }

      const { path, boardStateBeforeSow } = animationSteps[stepIndex];
      runOnJS(setAnimationBoard)(boardStateBeforeSow);
      const startPit = PIT_POSITIONS.find(p => p.index === path[0]);

      const scheduleNextStep = () => {
        animationTimers.current.push(setTimeout(() => playAnimationForStep(stepIndex + 1), 50));
      };

      if (!startPit || path.length <= 1) {
        scheduleNextStep();
        return;
      }

      const startPos = getSeedPosition(startPit.x, startPit.y, 0, 1);
      animatedX.value = startPos.x;
      animatedY.value = startPos.y;
      if (stepIndex === 0) animatedOpacity.value = withTiming(1, { duration: 80 });

      const durationPerHop = 250;
      const xSeq: any[] = [];
      const ySeq: any[] = [];

      for (let i = 1; i < path.length; i++) {
        const pit = PIT_POSITIONS.find(p => p.index === path[i]);
        if (!pit) continue;
        const pos = getSeedPosition(pit.x, pit.y, 0, 1);
        xSeq.push(withTiming(pos.x, { duration: durationPerHop, easing: Easing.inOut(Easing.ease) }));
        ySeq.push(withTiming(pos.y, { duration: durationPerHop, easing: Easing.inOut(Easing.ease) }, finished => {
          if (finished) {
            runOnJS(incrementSeedInPit)(path[i]);
            if (i === path.length - 1) runOnJS(scheduleNextStep)();
          }
        }));
      }

      if (xSeq.length > 0) {
        animatedX.value = withSequence(...xSeq);
        animatedY.value = withSequence(...ySeq);
      } else {
        runOnJS(scheduleNextStep)();
      }
    };

    playAnimationForStep(0);
  }, [animationSteps]);

  const animatedMatrix = useDerivedValue(() => Skia.Matrix().translate(animatedX.value * scale, animatedY.value * scale));
  const derivedAnimatedOpacity = useDerivedValue(() => animatedOpacity.value);
  const currentBoard = isAnimating ? animationBoard ?? boardBeforeMove : board;

  if (!boardImage || !seedImage) return null;

  return (
    <GestureDetector gesture={tapGesture}>
      <Canvas style={{ width: canvasWidth, height: canvasHeight }}>
        <SkiaImage image={boardImage} x={0} y={0} width={canvasWidth} height={canvasHeight} fit="fill" />
        {currentBoard.map((seedCount, pitIndex) => {
          if (seedCount === 0) return null;
          const pit = PIT_POSITIONS.find(p => p.index === pitIndex);
          if (!pit) return null;
          return Array.from({ length: seedCount }).map((_, seedIndex) => {
            const { x, y } = getSeedPosition(pit.x, pit.y, seedIndex, seedCount);
            return <SkiaImage key={`${pitIndex}-${seedIndex}`} image={seedImage} x={x * scale} y={y * scale} width={SEED_IMAGE_SIZE * scale} height={SEED_IMAGE_SIZE * scale} />;
          });
        })}
        <Group matrix={animatedMatrix} opacity={derivedAnimatedOpacity}>
          <SkiaImage image={seedImage} x={0} y={0} width={SEED_IMAGE_SIZE * scale} height={SEED_IMAGE_SIZE * scale} />
        </Group>
      </Canvas>
    </GestureDetector>
  );
};



// AyoComputerLogic.ts - computer opponent logic
import { AyoGameState, initializeGame, calculateMoveResult } from "../core/AyoCoreLogic";
import {
  randomMove,
  greedyMove,
  captureMove,
  scatterMove,
  alphaMove,
} from "./aiStrategies";

export type ComputerLevel = 1 | 2 | 3 | 4 | 5;

export interface AyoComputerState {
  game: AyoGameState;
  level: ComputerLevel;
  isPlayerWinner: boolean | null;
  reward: number;
}

export function initializeComputerGame(level: ComputerLevel): AyoComputerState {
  return {
    game: initializeGame(),
    level,
    isPlayerWinner: null,
    reward: 0,
  };
}

export function playComputerTurn(
  state: AyoComputerState,
  pitIndex: number
): AyoComputerState {
  const { nextState: game } = calculateMoveResult(state.game, pitIndex);

  const isPlayerWinner =
    game.scores[1] > 24
      ? true
      : game.scores[2] > 24
      ? false
      : null;
  const reward = isPlayerWinner ? 10 * state.level : 0;

  return { ...state, game, isPlayerWinner, reward };
}

export function getComputerMove(game: AyoGameState, level: ComputerLevel): number {
  switch (level) {
    case 1:
      return randomMove(game);
    case 2:
      return greedyMove(game);
    case 3:
      return captureMove(game);
    case 4:
      return scatterMove(game);
    case 5:
      return alphaMove(game, 4);
    default:
      return randomMove(game);
  }
}



// aiStrategies.ts - AI strategies implementation
import { AyoGameState, PLAYER_ONE_PITS, PLAYER_TWO_PITS, calculateMoveResult } from "../core/AyoCoreLogic";

export function getValidMoves(game: AyoGameState): number[] {
  const side = game.currentPlayer === 1 ? PLAYER_ONE_PITS : PLAYER_TWO_PITS;
  return side.filter((idx) => game.board[idx] > 0);
}

export function randomMove(game: AyoGameState): number {
  const validMoves = getValidMoves(game);
  return validMoves[Math.floor(Math.random() * validMoves.length)];
}

export function greedyMove(game: AyoGameState): number {
  const validMoves = getValidMoves(game);
  return validMoves.reduce((best, curr) =>
    game.board[curr] > game.board[best] ? curr : best
  );
}

export function captureMove(game: AyoGameState): number {
  const validMoves = getValidMoves(game);
  const opponentStart = game.currentPlayer === 1 ? 6 : 0;
  const found = validMoves.find((move) => ((move + game.board[move]) % 12) >= opponentStart && ((move + game.board[move]) % 12) < opponentStart + 6);
  return found ?? randomMove(game);
}

export function scatterMove(game: AyoGameState): number {
  const validMoves = getValidMoves(game);

  const ownSideStart = game.currentPlayer === 1 ? 0 : 6;
  const safeMove = validMoves.find(
    (move) => {
      const lastIdx = (move + game.board[move]) % 12;
      return lastIdx >= ownSideStart && lastIdx < ownSideStart + 6;
    }
  );

  return safeMove ?? greedyMove(game);
}

function evaluateGame(game: AyoGameState, player: 1 | 2): number {
  const opponent = player === 1 ? 2 : 1;
  const scoreDiff = (game.scores[player] - game.scores[opponent]) * 10;

  const playerPits = player === 1 ? PLAYER_ONE_PITS : PLAYER_TWO_PITS;
  const opponentPits = player === 1 ? PLAYER_TWO_PITS : PLAYER_ONE_PITS;
  const seedsPlayerSide = playerPits.reduce((s, i) => s + game.board[i], 0);
  const seedsOpponentSide = opponentPits.reduce((s, i) => s + game.board[i], 0);
  const sideDiff = seedsPlayerSide - seedsOpponentSide;

  return scoreDiff + sideDiff;
}

function minimaxAlphaBeta(
  game: AyoGameState,
  depth: number,
  alpha: number,
  beta: number,
  maximizing: boolean,
  player: 1 | 2
): number {
  const isTerminal = game.isGameOver || game.board.every((p) => p === 0);
  if (depth === 0 || isTerminal) {
    return evaluateGame(game, player);
  }

  const moves = getValidMoves(game);
  if (moves.length === 0) {
    return evaluateGame(game, player);
  }

  if (maximizing) {
    let value = -Infinity;
    for (const move of moves) {
      const { nextState } = calculateMoveResult(game, move);
      const evalScore = minimaxAlphaBeta(nextState, depth - 1, alpha, beta, false, player);
      value = Math.max(value, evalScore);
      alpha = Math.max(alpha, value);
      if (alpha >= beta) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (const move of moves) {
      const { nextState } = calculateMoveResult(game, move);
      const evalScore = minimaxAlphaBeta(nextState, depth - 1, alpha, beta, true, player);
      value = Math.min(value, evalScore);
      beta = Math.min(beta, value);
      if (beta <= alpha) break;
    }
    return value;
  }
}

export function alphaMove(game: AyoGameState, depth = 4): number {
  const validMoves = getValidMoves(game);
  const player = game.currentPlayer;
  let bestMove = validMoves[0];
  let bestScore = -Infinity;

  for (const move of validMoves) {
    const { nextState } = calculateMoveResult(game, move);
    const score = minimaxAlphaBeta(nextState, depth - 1, -Infinity, Infinity, false, player);
    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }

  return bestMove;
}
